#summary zooming rotating and panning the camera

We are locating the camera with the gluLookAt function:
 gluLookAt(cam.x , cam.y, cam.z, center.x, center.y, center.z, up.x, up.y, up.z)
this positions the camera at (cam.x , cam.y, cam.z) and it is pointed to look at the point (center.x, center.y, center.z). It is oriented so that camera up is in the direction (up.x, up.y, up.z)

It makes sense to internally represent the position of the camera in [http://mathworld.wolfram.com/SphericalCoordinates.html spherical coordinates]
 (r, theta, fi)
The transformation from spherical coords to cartesian is:
{{{
 cam.x = r * cos(theta) * sin(fi)
 cam.y = r * sin(theta) * sin(fi)
 cam.z = r * cos(fi)
}}}

if we want an upright view of our world then it probably makes sense to always have the *up* vector calculated to orient the camera upwards. If I remember correctly the result is quite horrible if up is constant
{{{
up=(0,0,1)
}}}

so, we need to always orient up towards polar north pole. I don't recall the exact description of this, but it works :)
{{{
u = (0,0,1)
v1 = u x cam
v1 = v1 / sqrt(v1.v1)
v2 = cam x v1
v2 = v2 / sqrt(v2.v2)
up = (u.v1)*v1 + (u.v2)*v2
up = up / sqrt(up.up)
}}}

here the dot (.) is used for vector dot-product and the cross (x) is used for vector cross product. star (*) is normal multiplication.
 

= zoom =
zoom is very easy, you just change r.

my suggestion is that this is done with the mouse-wheel.

for the up vector calculation above to work *it is important that r does not go to zero!*
= rotate =
this is also fairly easy.

to rotate side-to-side you change theta

to rotate up-down you change fi. it might be a good idea to restrict fi to -pi<fi<pi. try it out and see how it feels. 

= pan =
this is a bit harder. we want to pan in the plane which is perpendicular to the vector from the camera to center.